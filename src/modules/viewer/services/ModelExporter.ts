import JSZip from 'jszip';
import * as THREE from 'three';
import { STLExporter } from 'three-stdlib';

export class ModelExporter {
    private stlExporter: STLExporter;

    constructor() {
        this.stlExporter = new STLExporter();
    }

    async exportToZip(group: THREE.Group, modelName: string, specification?: any): Promise<Blob> {
        const zip = new JSZip();
        const meshFolder = zip.folder("mesh");

        // 1. Export meshes to STL
        const visuals: any[] = [];
        let meshIndex = 0;

        group.traverse((child) => {
            if ((child as THREE.Mesh).isMesh) {
                const mesh = child as THREE.Mesh;
                const stlData = this.stlExporter.parse(mesh, { binary: true });
                const meshFilename = mesh.name ? `${mesh.name}.stl` : `part_${meshIndex}.stl`;

                // stlData is a DataView, JSZip needs ArrayBuffer or Blob
                meshFolder?.file(meshFilename, stlData.buffer as ArrayBuffer);

                // Store visual info for SDF
                visuals.push({
                    name: mesh.name || `part_${meshIndex}`,
                    meshPath: `mesh/${meshFilename}`,
                    position: mesh.position.clone(),
                    rotation: mesh.rotation.clone(),
                    scale: mesh.scale.clone()
                });

                meshIndex++;
            }
        });

        // 2. Generate model.sdf
        const sdfContent = this.generateSDF(modelName, visuals);
        zip.file("model.sdf", sdfContent);

        // 3. Generate model.config
        const configContent = this.generateConfig(modelName);
        zip.file("model.config", configContent);

        // 4. Add specification if exists
        if (specification) {
            zip.file("specification", JSON.stringify(specification, null, 2));
        }

        // 5. Generate ZIP blob
        return await zip.generateAsync({ type: "blob" });
    }

    private generateSDF(name: string, visuals: any[]): string {
        let visualXml = "";

        visuals.forEach((v) => {
            // Gazebo is Z-up. When we export, we assume the Three.js Y-up positions 
            // are relative to the root group which was rotated. 
            // If we want the SDF to be "native" Z-up, we'd normally swap Y and Z.
            // However, to keep it simple and consistent with our importer, 
            // we export the positions as they are.
            const pos = `${v.position.x.toFixed(3)} ${v.position.y.toFixed(3)} ${v.position.z.toFixed(3)}`;
            const rot = `${v.rotation.x.toFixed(3)} ${v.rotation.y.toFixed(3)} ${v.rotation.z.toFixed(3)}`;

            visualXml += `
      <visual name='${v.name}'>
        <pose>${pos} ${rot}</pose>
        <geometry>
          <mesh>
            <uri>model://${name}/${v.meshPath}</uri>
            <scale>${v.scale.x} ${v.scale.y} ${v.scale.z}</scale>
          </mesh>
        </geometry>
      </visual>`;
        });

        return `<?xml version='1.0'?>
<sdf version='1.6'>
  <model name='${name}'>
    <static>true</static>
    <link name='link'>
      ${visualXml}
    </link>
  </model>
</sdf>`;
    }

    private generateConfig(name: string): string {
        return `<?xml version="1.0"?>
<model>
  <name>${name}</name>
  <version>1.0</version>
  <sdf version="1.6">model.sdf</sdf>
  <author>
    <name>CURFD AI</name>
    <email></email>
  </author>
  <description>
    Generated by CURFD AI
  </description>
</model>`;
    }

    downloadZip(blob: Blob, filename: string) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }
}
